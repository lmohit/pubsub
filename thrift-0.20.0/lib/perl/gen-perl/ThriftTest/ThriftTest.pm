#
# Autogenerated by Thrift Compiler (0.20.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use ThriftTest::Types;


# HELPER FUNCTIONS AND STRUCTURES

package ThriftTest::ThriftTest_testVoid_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testVoid_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testVoid_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testVoid_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testVoid_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testVoid_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testString_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testString_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testString_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testString_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testString_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testString_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testString_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testString_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testBool_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testBool_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testBool_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testBool_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::BOOL, 1);
    $xfer += $output->writeBool($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testBool_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testBool_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testBool_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testBool_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testByte_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testByte_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testByte_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testByte_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::BYTE, 1);
    $xfer += $output->writeByte($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testByte_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testByte_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testByte_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testByte_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI32_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI32_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI32_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI32_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI64_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI64_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI64_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI64_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI64_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI64_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI64_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI64_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testDouble_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testDouble_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testDouble_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testDouble_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::DOUBLE, 1);
    $xfer += $output->writeDouble($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testDouble_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testDouble_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testDouble_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testDouble_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::DOUBLE, 0);
    $xfer += $output->writeDouble($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testBinary_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testBinary_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testBinary_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testBinary_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testBinary_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testBinary_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testBinary_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testBinary_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStruct_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStruct_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStruct_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{thing} = ThriftTest::Xtruct->new();
        $xfer += $self->{thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStruct_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::STRUCT, 1);
    $xfer += $self->{thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStruct_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStruct_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStruct_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = ThriftTest::Xtruct->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStruct_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testNest_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testNest_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testNest_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{thing} = ThriftTest::Xtruct2->new();
        $xfer += $self->{thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testNest_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::STRUCT, 1);
    $xfer += $self->{thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testNest_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testNest_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testNest_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = ThriftTest::Xtruct2->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testNest_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMap_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size286 = 0;
          $self->{thing} = {};
          my $_ktype287 = 0;
          my $_vtype288 = 0;
          $xfer += $input->readMapBegin(\$_ktype287, \$_vtype288, \$_size286);
          for (my $_i290 = 0; $_i290 < $_size286; ++$_i290)
          {
            my $key291 = 0;
            my $val292 = 0;
            $xfer += $input->readI32(\$key291);
            $xfer += $input->readI32(\$val292);
            $self->{thing}->{$key291} = $val292;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMap_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I32, scalar(keys %{$self->{thing}}));
      {
        while( my ($kiter293,$viter294) = each %{$self->{thing}}) 
        {
          $xfer += $output->writeI32($kiter293);
          $xfer += $output->writeI32($viter294);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size295 = 0;
          $self->{success} = {};
          my $_ktype296 = 0;
          my $_vtype297 = 0;
          $xfer += $input->readMapBegin(\$_ktype296, \$_vtype297, \$_size295);
          for (my $_i299 = 0; $_i299 < $_size295; ++$_i299)
          {
            my $key300 = 0;
            my $val301 = 0;
            $xfer += $input->readI32(\$key300);
            $xfer += $input->readI32(\$val301);
            $self->{success}->{$key300} = $val301;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I32, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter302,$viter303) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI32($kiter302);
          $xfer += $output->writeI32($viter303);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStringMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStringMap_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStringMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size304 = 0;
          $self->{thing} = {};
          my $_ktype305 = 0;
          my $_vtype306 = 0;
          $xfer += $input->readMapBegin(\$_ktype305, \$_vtype306, \$_size304);
          for (my $_i308 = 0; $_i308 < $_size304; ++$_i308)
          {
            my $key309 = '';
            my $val310 = '';
            $xfer += $input->readString(\$key309);
            $xfer += $input->readString(\$val310);
            $self->{thing}->{$key309} = $val310;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStringMap_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{thing}}));
      {
        while( my ($kiter311,$viter312) = each %{$self->{thing}}) 
        {
          $xfer += $output->writeString($kiter311);
          $xfer += $output->writeString($viter312);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStringMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStringMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStringMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size313 = 0;
          $self->{success} = {};
          my $_ktype314 = 0;
          my $_vtype315 = 0;
          $xfer += $input->readMapBegin(\$_ktype314, \$_vtype315, \$_size313);
          for (my $_i317 = 0; $_i317 < $_size313; ++$_i317)
          {
            my $key318 = '';
            my $val319 = '';
            $xfer += $input->readString(\$key318);
            $xfer += $input->readString(\$val319);
            $self->{success}->{$key318} = $val319;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStringMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter320,$viter321) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter320);
          $xfer += $output->writeString($viter321);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testSet_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testSet_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testSet_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size322 = 0;
          $self->{thing} = {};
          my $_etype325 = 0;
          $xfer += $input->readSetBegin(\$_etype325, \$_size322);
          for (my $_i326 = 0; $_i326 < $_size322; ++$_i326)
          {
            my $elem327 = undef;
            $xfer += $input->readI32(\$elem327);
            $self->{thing}->{$elem327} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testSet_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::SET, 1);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::I32, scalar(@{$self->{thing}}));
      {
        foreach my $iter328 (@{$self->{thing}})
        {
          $xfer += $output->writeI32($iter328);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testSet_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testSet_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testSet_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size329 = 0;
          $self->{success} = {};
          my $_etype332 = 0;
          $xfer += $input->readSetBegin(\$_etype332, \$_size329);
          for (my $_i333 = 0; $_i333 < $_size329; ++$_i333)
          {
            my $elem334 = undef;
            $xfer += $input->readI32(\$elem334);
            $self->{success}->{$elem334} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testSet_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::SET, 0);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::I32, scalar(@{$self->{success}}));
      {
        foreach my $iter335 (@{$self->{success}})
        {
          $xfer += $output->writeI32($iter335);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testList_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testList_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size336 = 0;
          $self->{thing} = [];
          my $_etype339 = 0;
          $xfer += $input->readListBegin(\$_etype339, \$_size336);
          for (my $_i340 = 0; $_i340 < $_size336; ++$_i340)
          {
            my $elem341 = undef;
            $xfer += $input->readI32(\$elem341);
            push(@{$self->{thing}},$elem341);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testList_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{thing}}));
      {
        foreach my $iter342 (@{$self->{thing}}) 
        {
          $xfer += $output->writeI32($iter342);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testList_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size343 = 0;
          $self->{success} = [];
          my $_etype346 = 0;
          $xfer += $input->readListBegin(\$_etype346, \$_size343);
          for (my $_i347 = 0; $_i347 < $_size343; ++$_i347)
          {
            my $elem348 = undef;
            $xfer += $input->readI32(\$elem348);
            push(@{$self->{success}},$elem348);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{success}}));
      {
        foreach my $iter349 (@{$self->{success}}) 
        {
          $xfer += $output->writeI32($iter349);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testEnum_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testEnum_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testEnum_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testEnum_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testEnum_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testEnum_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testEnum_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testEnum_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testTypedef_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testTypedef_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testTypedef_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testTypedef_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testTypedef_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testTypedef_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testTypedef_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testTypedef_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMapMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMapMap_args->mk_accessors( qw( hello ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{hello} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{hello}) {
      $self->{hello} = $vals->{hello};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMapMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{hello});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMapMap_args');
  if (defined $self->{hello}) {
    $xfer += $output->writeFieldBegin('hello', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{hello});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMapMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMapMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMapMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size350 = 0;
          $self->{success} = {};
          my $_ktype351 = 0;
          my $_vtype352 = 0;
          $xfer += $input->readMapBegin(\$_ktype351, \$_vtype352, \$_size350);
          for (my $_i354 = 0; $_i354 < $_size350; ++$_i354)
          {
            my $key355 = 0;
            my $val356 = [];
            $xfer += $input->readI32(\$key355);
            {
              my $_size357 = 0;
              $val356 = {};
              my $_ktype358 = 0;
              my $_vtype359 = 0;
              $xfer += $input->readMapBegin(\$_ktype358, \$_vtype359, \$_size357);
              for (my $_i361 = 0; $_i361 < $_size357; ++$_i361)
              {
                my $key362 = 0;
                my $val363 = 0;
                $xfer += $input->readI32(\$key362);
                $xfer += $input->readI32(\$val363);
                $val356->{$key362} = $val363;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key355} = $val356;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMapMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter364,$viter365) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI32($kiter364);
          {
            $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I32, scalar(keys %{${viter365}}));
            {
              while( my ($kiter366,$viter367) = each %{${viter365}}) 
              {
                $xfer += $output->writeI32($kiter366);
                $xfer += $output->writeI32($viter367);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testInsanity_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testInsanity_args->mk_accessors( qw( argument ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{argument} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{argument}) {
      $self->{argument} = $vals->{argument};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testInsanity_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{argument} = ThriftTest::Insanity->new();
        $xfer += $self->{argument}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testInsanity_args');
  if (defined $self->{argument}) {
    $xfer += $output->writeFieldBegin('argument', Thrift::TType::STRUCT, 1);
    $xfer += $self->{argument}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testInsanity_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testInsanity_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testInsanity_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size368 = 0;
          $self->{success} = {};
          my $_ktype369 = 0;
          my $_vtype370 = 0;
          $xfer += $input->readMapBegin(\$_ktype369, \$_vtype370, \$_size368);
          for (my $_i372 = 0; $_i372 < $_size368; ++$_i372)
          {
            my $key373 = 0;
            my $val374 = [];
            $xfer += $input->readI64(\$key373);
            {
              my $_size375 = 0;
              $val374 = {};
              my $_ktype376 = 0;
              my $_vtype377 = 0;
              $xfer += $input->readMapBegin(\$_ktype376, \$_vtype377, \$_size375);
              for (my $_i379 = 0; $_i379 < $_size375; ++$_i379)
              {
                my $key380 = 0;
                my $val381 = ThriftTest::Insanity->new();
                $xfer += $input->readI32(\$key380);
                $val381 = ThriftTest::Insanity->new();
                $xfer += $val381->read($input);
                $val374->{$key380} = $val381;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key373} = $val374;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testInsanity_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I64, Thrift::TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter382,$viter383) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI64($kiter382);
          {
            $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::STRUCT, scalar(keys %{${viter383}}));
            {
              while( my ($kiter384,$viter385) = each %{${viter383}}) 
              {
                $xfer += $output->writeI32($kiter384);
                $xfer += ${viter385}->write($output);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMulti_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMulti_args->mk_accessors( qw( arg0 arg1 arg2 arg3 arg4 arg5 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg0} = undef;
  $self->{arg1} = undef;
  $self->{arg2} = undef;
  $self->{arg3} = undef;
  $self->{arg4} = undef;
  $self->{arg5} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg0}) {
      $self->{arg0} = $vals->{arg0};
    }
    if (defined $vals->{arg1}) {
      $self->{arg1} = $vals->{arg1};
    }
    if (defined $vals->{arg2}) {
      $self->{arg2} = $vals->{arg2};
    }
    if (defined $vals->{arg3}) {
      $self->{arg3} = $vals->{arg3};
    }
    if (defined $vals->{arg4}) {
      $self->{arg4} = $vals->{arg4};
    }
    if (defined $vals->{arg5}) {
      $self->{arg5} = $vals->{arg5};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMulti_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{arg0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{arg1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{arg2});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size386 = 0;
          $self->{arg3} = {};
          my $_ktype387 = 0;
          my $_vtype388 = 0;
          $xfer += $input->readMapBegin(\$_ktype387, \$_vtype388, \$_size386);
          for (my $_i390 = 0; $_i390 < $_size386; ++$_i390)
          {
            my $key391 = 0;
            my $val392 = '';
            $xfer += $input->readI16(\$key391);
            $xfer += $input->readString(\$val392);
            $self->{arg3}->{$key391} = $val392;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{arg4});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{arg5});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMulti_args');
  if (defined $self->{arg0}) {
    $xfer += $output->writeFieldBegin('arg0', Thrift::TType::BYTE, 1);
    $xfer += $output->writeByte($self->{arg0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg1}) {
    $xfer += $output->writeFieldBegin('arg1', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{arg1});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg2}) {
    $xfer += $output->writeFieldBegin('arg2', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{arg2});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg3}) {
    $xfer += $output->writeFieldBegin('arg3', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I16, Thrift::TType::STRING, scalar(keys %{$self->{arg3}}));
      {
        while( my ($kiter393,$viter394) = each %{$self->{arg3}}) 
        {
          $xfer += $output->writeI16($kiter393);
          $xfer += $output->writeString($viter394);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg4}) {
    $xfer += $output->writeFieldBegin('arg4', Thrift::TType::I32, 5);
    $xfer += $output->writeI32($self->{arg4});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg5}) {
    $xfer += $output->writeFieldBegin('arg5', Thrift::TType::I64, 6);
    $xfer += $output->writeI64($self->{arg5});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMulti_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMulti_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMulti_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = ThriftTest::Xtruct->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMulti_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testException_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testException_args->mk_accessors( qw( arg ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg}) {
      $self->{arg} = $vals->{arg};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testException_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{arg});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testException_args');
  if (defined $self->{arg}) {
    $xfer += $output->writeFieldBegin('arg', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{arg});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testException_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testException_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{err1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{err1}) {
      $self->{err1} = $vals->{err1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testException_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{err1} = ThriftTest::Xception->new();
        $xfer += $self->{err1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testException_result');
  if (defined $self->{err1}) {
    $xfer += $output->writeFieldBegin('err1', Thrift::TType::STRUCT, 1);
    $xfer += $self->{err1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMultiException_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMultiException_args->mk_accessors( qw( arg0 arg1 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg0} = undef;
  $self->{arg1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg0}) {
      $self->{arg0} = $vals->{arg0};
    }
    if (defined $vals->{arg1}) {
      $self->{arg1} = $vals->{arg1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMultiException_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{arg0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{arg1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMultiException_args');
  if (defined $self->{arg0}) {
    $xfer += $output->writeFieldBegin('arg0', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{arg0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg1}) {
    $xfer += $output->writeFieldBegin('arg1', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{arg1});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMultiException_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMultiException_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{err1} = undef;
  $self->{err2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{err1}) {
      $self->{err1} = $vals->{err1};
    }
    if (defined $vals->{err2}) {
      $self->{err2} = $vals->{err2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMultiException_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = ThriftTest::Xtruct->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{err1} = ThriftTest::Xception->new();
        $xfer += $self->{err1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{err2} = ThriftTest::Xception2->new();
        $xfer += $self->{err2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMultiException_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{err1}) {
    $xfer += $output->writeFieldBegin('err1', Thrift::TType::STRUCT, 1);
    $xfer += $self->{err1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{err2}) {
    $xfer += $output->writeFieldBegin('err2', Thrift::TType::STRUCT, 2);
    $xfer += $self->{err2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testOneway_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testOneway_args->mk_accessors( qw( secondsToSleep ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{secondsToSleep} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{secondsToSleep}) {
      $self->{secondsToSleep} = $vals->{secondsToSleep};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testOneway_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{secondsToSleep});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testOneway_args');
  if (defined $self->{secondsToSleep}) {
    $xfer += $output->writeFieldBegin('secondsToSleep', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{secondsToSleep});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testOneway_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testOneway_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testOneway_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTestIf;

use strict;


sub testVoid{
  my $self = shift;

  die 'implement interface';
}

sub testString{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testBool{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testByte{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testI32{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testI64{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testDouble{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testBinary{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testStruct{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testNest{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testMap{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testStringMap{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testSet{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testList{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testEnum{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testTypedef{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testMapMap{
  my $self = shift;
  my $hello = shift;

  die 'implement interface';
}

sub testInsanity{
  my $self = shift;
  my $argument = shift;

  die 'implement interface';
}

sub testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

  die 'implement interface';
}

sub testException{
  my $self = shift;
  my $arg = shift;

  die 'implement interface';
}

sub testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

  die 'implement interface';
}

sub testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

  die 'implement interface';
}

package ThriftTest::ThriftTestRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub testVoid{
  my ($self, $request) = @_;

  return $self->{impl}->testVoid();
}

sub testString{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testString($thing);
}

sub testBool{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testBool($thing);
}

sub testByte{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testByte($thing);
}

sub testI32{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testI32($thing);
}

sub testI64{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testI64($thing);
}

sub testDouble{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testDouble($thing);
}

sub testBinary{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testBinary($thing);
}

sub testStruct{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testStruct($thing);
}

sub testNest{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testNest($thing);
}

sub testMap{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testMap($thing);
}

sub testStringMap{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testStringMap($thing);
}

sub testSet{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testSet($thing);
}

sub testList{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testList($thing);
}

sub testEnum{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testEnum($thing);
}

sub testTypedef{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testTypedef($thing);
}

sub testMapMap{
  my ($self, $request) = @_;

  my $hello = ($request->{'hello'}) ? $request->{'hello'} : undef;
  return $self->{impl}->testMapMap($hello);
}

sub testInsanity{
  my ($self, $request) = @_;

  my $argument = ($request->{'argument'}) ? $request->{'argument'} : undef;
  return $self->{impl}->testInsanity($argument);
}

sub testMulti{
  my ($self, $request) = @_;

  my $arg0 = ($request->{'arg0'}) ? $request->{'arg0'} : undef;
  my $arg1 = ($request->{'arg1'}) ? $request->{'arg1'} : undef;
  my $arg2 = ($request->{'arg2'}) ? $request->{'arg2'} : undef;
  my $arg3 = ($request->{'arg3'}) ? $request->{'arg3'} : undef;
  my $arg4 = ($request->{'arg4'}) ? $request->{'arg4'} : undef;
  my $arg5 = ($request->{'arg5'}) ? $request->{'arg5'} : undef;
  return $self->{impl}->testMulti($arg0, $arg1, $arg2, $arg3, $arg4, $arg5);
}

sub testException{
  my ($self, $request) = @_;

  my $arg = ($request->{'arg'}) ? $request->{'arg'} : undef;
  return $self->{impl}->testException($arg);
}

sub testMultiException{
  my ($self, $request) = @_;

  my $arg0 = ($request->{'arg0'}) ? $request->{'arg0'} : undef;
  my $arg1 = ($request->{'arg1'}) ? $request->{'arg1'} : undef;
  return $self->{impl}->testMultiException($arg0, $arg1);
}

sub testOneway{
  my ($self, $request) = @_;

  my $secondsToSleep = ($request->{'secondsToSleep'}) ? $request->{'secondsToSleep'} : undef;
  return $self->{impl}->testOneway($secondsToSleep);
}

package ThriftTest::ThriftTestClient;


use base qw(ThriftTest::ThriftTestIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub testVoid{
  my $self = shift;

    $self->send_testVoid();
  $self->recv_testVoid();
}

sub send_testVoid{
  my $self = shift;

  $self->{output}->writeMessageBegin('testVoid', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testVoid_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testVoid{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testVoid_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub testString{
  my $self = shift;
  my $thing = shift;

    $self->send_testString($thing);
  return $self->recv_testString();
}

sub send_testString{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testString', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testString_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testString{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testString_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testString failed: unknown result";
}
sub testBool{
  my $self = shift;
  my $thing = shift;

    $self->send_testBool($thing);
  return $self->recv_testBool();
}

sub send_testBool{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testBool', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testBool_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testBool{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testBool_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testBool failed: unknown result";
}
sub testByte{
  my $self = shift;
  my $thing = shift;

    $self->send_testByte($thing);
  return $self->recv_testByte();
}

sub send_testByte{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testByte', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testByte_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testByte{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testByte_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testByte failed: unknown result";
}
sub testI32{
  my $self = shift;
  my $thing = shift;

    $self->send_testI32($thing);
  return $self->recv_testI32();
}

sub send_testI32{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testI32', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testI32_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testI32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testI32_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testI32 failed: unknown result";
}
sub testI64{
  my $self = shift;
  my $thing = shift;

    $self->send_testI64($thing);
  return $self->recv_testI64();
}

sub send_testI64{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testI64', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testI64_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testI64{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testI64_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testI64 failed: unknown result";
}
sub testDouble{
  my $self = shift;
  my $thing = shift;

    $self->send_testDouble($thing);
  return $self->recv_testDouble();
}

sub send_testDouble{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testDouble', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testDouble_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testDouble{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testDouble_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testDouble failed: unknown result";
}
sub testBinary{
  my $self = shift;
  my $thing = shift;

    $self->send_testBinary($thing);
  return $self->recv_testBinary();
}

sub send_testBinary{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testBinary', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testBinary_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testBinary{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testBinary_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testBinary failed: unknown result";
}
sub testStruct{
  my $self = shift;
  my $thing = shift;

    $self->send_testStruct($thing);
  return $self->recv_testStruct();
}

sub send_testStruct{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testStruct', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testStruct_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testStruct{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testStruct_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testStruct failed: unknown result";
}
sub testNest{
  my $self = shift;
  my $thing = shift;

    $self->send_testNest($thing);
  return $self->recv_testNest();
}

sub send_testNest{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testNest', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testNest_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testNest{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testNest_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testNest failed: unknown result";
}
sub testMap{
  my $self = shift;
  my $thing = shift;

    $self->send_testMap($thing);
  return $self->recv_testMap();
}

sub send_testMap{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testMap', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testMap_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testMap_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMap failed: unknown result";
}
sub testStringMap{
  my $self = shift;
  my $thing = shift;

    $self->send_testStringMap($thing);
  return $self->recv_testStringMap();
}

sub send_testStringMap{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testStringMap', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testStringMap_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testStringMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testStringMap_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testStringMap failed: unknown result";
}
sub testSet{
  my $self = shift;
  my $thing = shift;

    $self->send_testSet($thing);
  return $self->recv_testSet();
}

sub send_testSet{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testSet', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testSet_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testSet{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testSet_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testSet failed: unknown result";
}
sub testList{
  my $self = shift;
  my $thing = shift;

    $self->send_testList($thing);
  return $self->recv_testList();
}

sub send_testList{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testList', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testList_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testList_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testList failed: unknown result";
}
sub testEnum{
  my $self = shift;
  my $thing = shift;

    $self->send_testEnum($thing);
  return $self->recv_testEnum();
}

sub send_testEnum{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testEnum', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testEnum_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testEnum{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testEnum_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testEnum failed: unknown result";
}
sub testTypedef{
  my $self = shift;
  my $thing = shift;

    $self->send_testTypedef($thing);
  return $self->recv_testTypedef();
}

sub send_testTypedef{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testTypedef', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testTypedef_args->new();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testTypedef{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testTypedef_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testTypedef failed: unknown result";
}
sub testMapMap{
  my $self = shift;
  my $hello = shift;

    $self->send_testMapMap($hello);
  return $self->recv_testMapMap();
}

sub send_testMapMap{
  my $self = shift;
  my $hello = shift;

  $self->{output}->writeMessageBegin('testMapMap', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testMapMap_args->new();
  $args->{hello} = $hello;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMapMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testMapMap_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMapMap failed: unknown result";
}
sub testInsanity{
  my $self = shift;
  my $argument = shift;

    $self->send_testInsanity($argument);
  return $self->recv_testInsanity();
}

sub send_testInsanity{
  my $self = shift;
  my $argument = shift;

  $self->{output}->writeMessageBegin('testInsanity', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testInsanity_args->new();
  $args->{argument} = $argument;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testInsanity{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testInsanity_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testInsanity failed: unknown result";
}
sub testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

    $self->send_testMulti($arg0, $arg1, $arg2, $arg3, $arg4, $arg5);
  return $self->recv_testMulti();
}

sub send_testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

  $self->{output}->writeMessageBegin('testMulti', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testMulti_args->new();
  $args->{arg0} = $arg0;
  $args->{arg1} = $arg1;
  $args->{arg2} = $arg2;
  $args->{arg3} = $arg3;
  $args->{arg4} = $arg4;
  $args->{arg5} = $arg5;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMulti{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testMulti_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMulti failed: unknown result";
}
sub testException{
  my $self = shift;
  my $arg = shift;

    $self->send_testException($arg);
  $self->recv_testException();
}

sub send_testException{
  my $self = shift;
  my $arg = shift;

  $self->{output}->writeMessageBegin('testException', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testException_args->new();
  $args->{arg} = $arg;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testException{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testException_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{err1}) {
    die $result->{err1};
  }
  return;
}
sub testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

    $self->send_testMultiException($arg0, $arg1);
  return $self->recv_testMultiException();
}

sub send_testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

  $self->{output}->writeMessageBegin('testMultiException', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testMultiException_args->new();
  $args->{arg0} = $arg0;
  $args->{arg1} = $arg1;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMultiException{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = ThriftTest::ThriftTest_testMultiException_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{err1}) {
    die $result->{err1};
  }
  if (defined $result->{err2}) {
    die $result->{err2};
  }
  die "testMultiException failed: unknown result";
}
sub testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

    $self->send_testOneway($secondsToSleep);
}

sub send_testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

  $self->{output}->writeMessageBegin('testOneway', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = ThriftTest::ThriftTest_testOneway_args->new();
  $args->{secondsToSleep} = $secondsToSleep;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
package ThriftTest::ThriftTestProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(Thrift::TType::STRUCT);
      $input->readMessageEnd();
      my $x = Thrift::TApplicationException->new('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_testVoid {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testVoid_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testVoid_result->new();
    $self->{handler}->testVoid();
    $output->writeMessageBegin('testVoid', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testString {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testString_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testString_result->new();
    $result->{success} = $self->{handler}->testString($args->thing);
    $output->writeMessageBegin('testString', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testBool {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testBool_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testBool_result->new();
    $result->{success} = $self->{handler}->testBool($args->thing);
    $output->writeMessageBegin('testBool', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testByte {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testByte_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testByte_result->new();
    $result->{success} = $self->{handler}->testByte($args->thing);
    $output->writeMessageBegin('testByte', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testI32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testI32_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testI32_result->new();
    $result->{success} = $self->{handler}->testI32($args->thing);
    $output->writeMessageBegin('testI32', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testI64 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testI64_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testI64_result->new();
    $result->{success} = $self->{handler}->testI64($args->thing);
    $output->writeMessageBegin('testI64', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testDouble {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testDouble_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testDouble_result->new();
    $result->{success} = $self->{handler}->testDouble($args->thing);
    $output->writeMessageBegin('testDouble', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testBinary {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testBinary_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testBinary_result->new();
    $result->{success} = $self->{handler}->testBinary($args->thing);
    $output->writeMessageBegin('testBinary', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testStruct {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testStruct_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testStruct_result->new();
    $result->{success} = $self->{handler}->testStruct($args->thing);
    $output->writeMessageBegin('testStruct', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testNest {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testNest_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testNest_result->new();
    $result->{success} = $self->{handler}->testNest($args->thing);
    $output->writeMessageBegin('testNest', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testMap_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testMap_result->new();
    $result->{success} = $self->{handler}->testMap($args->thing);
    $output->writeMessageBegin('testMap', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testStringMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testStringMap_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testStringMap_result->new();
    $result->{success} = $self->{handler}->testStringMap($args->thing);
    $output->writeMessageBegin('testStringMap', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testSet {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testSet_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testSet_result->new();
    $result->{success} = $self->{handler}->testSet($args->thing);
    $output->writeMessageBegin('testSet', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testList_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testList_result->new();
    $result->{success} = $self->{handler}->testList($args->thing);
    $output->writeMessageBegin('testList', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testEnum {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testEnum_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testEnum_result->new();
    $result->{success} = $self->{handler}->testEnum($args->thing);
    $output->writeMessageBegin('testEnum', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testTypedef {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testTypedef_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testTypedef_result->new();
    $result->{success} = $self->{handler}->testTypedef($args->thing);
    $output->writeMessageBegin('testTypedef', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMapMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testMapMap_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testMapMap_result->new();
    $result->{success} = $self->{handler}->testMapMap($args->hello);
    $output->writeMessageBegin('testMapMap', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testInsanity {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testInsanity_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testInsanity_result->new();
    $result->{success} = $self->{handler}->testInsanity($args->argument);
    $output->writeMessageBegin('testInsanity', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMulti {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testMulti_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testMulti_result->new();
    $result->{success} = $self->{handler}->testMulti($args->arg0, $args->arg1, $args->arg2, $args->arg3, $args->arg4, $args->arg5);
    $output->writeMessageBegin('testMulti', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testException {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testException_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testException_result->new();
    eval {
      $self->{handler}->testException($args->arg);
    }; if( UNIVERSAL::isa($@,'ThriftTest::Xception') ){ 
      $result->{err1} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('testException', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('testException', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMultiException {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testMultiException_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = ThriftTest::ThriftTest_testMultiException_result->new();
    eval {
      $result->{success} = $self->{handler}->testMultiException($args->arg0, $args->arg1);
    }; if( UNIVERSAL::isa($@,'ThriftTest::Xception') ){ 
      $result->{err1} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'ThriftTest::Xception2') ){ 
      $result->{err2} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('testMultiException', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('testMultiException', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testOneway {
    my ($self, $seqid, $input, $output) = @_;
    my $args = ThriftTest::ThriftTest_testOneway_args->new();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->testOneway($args->secondsToSleep);
    return;
}
1;
