#
# Autogenerated by Thrift Compiler (0.20.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

package ThriftTest::Numberz;
use constant ONE => 1;
use constant TWO => 2;
use constant THREE => 3;
use constant FIVE => 5;
use constant SIX => 6;
use constant EIGHT => 8;

package ThriftTest::Bonk;
use base qw(Class::Accessor);
ThriftTest::Bonk->mk_accessors( qw( message type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Bonk';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Bonk');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Bools;
use base qw(Class::Accessor);
ThriftTest::Bools->mk_accessors( qw( im_true im_false ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{im_true} = undef;
  $self->{im_false} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{im_true}) {
      $self->{im_true} = $vals->{im_true};
    }
    if (defined $vals->{im_false}) {
      $self->{im_false} = $vals->{im_false};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Bools';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{im_true});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{im_false});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Bools');
  if (defined $self->{im_true}) {
    $xfer += $output->writeFieldBegin('im_true', Thrift::TType::BOOL, 1);
    $xfer += $output->writeBool($self->{im_true});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{im_false}) {
    $xfer += $output->writeFieldBegin('im_false', Thrift::TType::BOOL, 2);
    $xfer += $output->writeBool($self->{im_false});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xtruct;
use base qw(Class::Accessor);
ThriftTest::Xtruct->mk_accessors( qw( string_thing byte_thing i32_thing i64_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{string_thing} = undef;
  $self->{byte_thing} = undef;
  $self->{i32_thing} = undef;
  $self->{i64_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{string_thing}) {
      $self->{string_thing} = $vals->{string_thing};
    }
    if (defined $vals->{byte_thing}) {
      $self->{byte_thing} = $vals->{byte_thing};
    }
    if (defined $vals->{i32_thing}) {
      $self->{i32_thing} = $vals->{i32_thing};
    }
    if (defined $vals->{i64_thing}) {
      $self->{i64_thing} = $vals->{i64_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xtruct';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{string_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{byte_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{i32_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{i64_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xtruct');
  if (defined $self->{string_thing}) {
    $xfer += $output->writeFieldBegin('string_thing', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{string_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{byte_thing}) {
    $xfer += $output->writeFieldBegin('byte_thing', Thrift::TType::BYTE, 4);
    $xfer += $output->writeByte($self->{byte_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32_thing}) {
    $xfer += $output->writeFieldBegin('i32_thing', Thrift::TType::I32, 9);
    $xfer += $output->writeI32($self->{i32_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i64_thing}) {
    $xfer += $output->writeFieldBegin('i64_thing', Thrift::TType::I64, 11);
    $xfer += $output->writeI64($self->{i64_thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xtruct2;
use base qw(Class::Accessor);
ThriftTest::Xtruct2->mk_accessors( qw( byte_thing struct_thing i32_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{byte_thing} = undef;
  $self->{struct_thing} = undef;
  $self->{i32_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{byte_thing}) {
      $self->{byte_thing} = $vals->{byte_thing};
    }
    if (defined $vals->{struct_thing}) {
      $self->{struct_thing} = $vals->{struct_thing};
    }
    if (defined $vals->{i32_thing}) {
      $self->{i32_thing} = $vals->{i32_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xtruct2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{byte_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{struct_thing} = ThriftTest::Xtruct->new();
        $xfer += $self->{struct_thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{i32_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xtruct2');
  if (defined $self->{byte_thing}) {
    $xfer += $output->writeFieldBegin('byte_thing', Thrift::TType::BYTE, 1);
    $xfer += $output->writeByte($self->{byte_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{struct_thing}) {
    $xfer += $output->writeFieldBegin('struct_thing', Thrift::TType::STRUCT, 2);
    $xfer += $self->{struct_thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32_thing}) {
    $xfer += $output->writeFieldBegin('i32_thing', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{i32_thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xtruct3;
use base qw(Class::Accessor);
ThriftTest::Xtruct3->mk_accessors( qw( string_thing changed i32_thing i64_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{string_thing} = undef;
  $self->{changed} = undef;
  $self->{i32_thing} = undef;
  $self->{i64_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{string_thing}) {
      $self->{string_thing} = $vals->{string_thing};
    }
    if (defined $vals->{changed}) {
      $self->{changed} = $vals->{changed};
    }
    if (defined $vals->{i32_thing}) {
      $self->{i32_thing} = $vals->{i32_thing};
    }
    if (defined $vals->{i64_thing}) {
      $self->{i64_thing} = $vals->{i64_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xtruct3';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{string_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{changed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{i32_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{i64_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xtruct3');
  if (defined $self->{string_thing}) {
    $xfer += $output->writeFieldBegin('string_thing', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{string_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{changed}) {
    $xfer += $output->writeFieldBegin('changed', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{changed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32_thing}) {
    $xfer += $output->writeFieldBegin('i32_thing', Thrift::TType::I32, 9);
    $xfer += $output->writeI32($self->{i32_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i64_thing}) {
    $xfer += $output->writeFieldBegin('i64_thing', Thrift::TType::I64, 11);
    $xfer += $output->writeI64($self->{i64_thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Insanity;
use base qw(Class::Accessor);
ThriftTest::Insanity->mk_accessors( qw( userMap xtructs ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userMap} = undef;
  $self->{xtructs} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userMap}) {
      $self->{userMap} = $vals->{userMap};
    }
    if (defined $vals->{xtructs}) {
      $self->{xtructs} = $vals->{xtructs};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Insanity';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size0 = 0;
          $self->{userMap} = {};
          my $_ktype1 = 0;
          my $_vtype2 = 0;
          $xfer += $input->readMapBegin(\$_ktype1, \$_vtype2, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $key5 = 0;
            my $val6 = 0;
            $xfer += $input->readI32(\$key5);
            $xfer += $input->readI64(\$val6);
            $self->{userMap}->{$key5} = $val6;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size7 = 0;
          $self->{xtructs} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = ThriftTest::Xtruct->new();
            $xfer += $elem12->read($input);
            push(@{$self->{xtructs}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Insanity');
  if (defined $self->{userMap}) {
    $xfer += $output->writeFieldBegin('userMap', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I64, scalar(keys %{$self->{userMap}}));
      {
        while( my ($kiter13,$viter14) = each %{$self->{userMap}}) 
        {
          $xfer += $output->writeI32($kiter13);
          $xfer += $output->writeI64($viter14);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{xtructs}) {
    $xfer += $output->writeFieldBegin('xtructs', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{xtructs}}));
      {
        foreach my $iter15 (@{$self->{xtructs}}) 
        {
          $xfer += ${iter15}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::CrazyNesting;
use base qw(Class::Accessor);
ThriftTest::CrazyNesting->mk_accessors( qw( string_field set_field list_field binary_field ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{string_field} = undef;
  $self->{set_field} = undef;
  $self->{list_field} = undef;
  $self->{binary_field} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{string_field}) {
      $self->{string_field} = $vals->{string_field};
    }
    if (defined $vals->{set_field}) {
      $self->{set_field} = $vals->{set_field};
    }
    if (defined $vals->{list_field}) {
      $self->{list_field} = $vals->{list_field};
    }
    if (defined $vals->{binary_field}) {
      $self->{binary_field} = $vals->{binary_field};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CrazyNesting';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{string_field});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size16 = 0;
          $self->{set_field} = {};
          my $_etype19 = 0;
          $xfer += $input->readSetBegin(\$_etype19, \$_size16);
          for (my $_i20 = 0; $_i20 < $_size16; ++$_i20)
          {
            my $elem21 = undef;
            $elem21 = ThriftTest::Insanity->new();
            $xfer += $elem21->read($input);
            $self->{set_field}->{$elem21} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size22 = 0;
          $self->{list_field} = [];
          my $_etype25 = 0;
          $xfer += $input->readListBegin(\$_etype25, \$_size22);
          for (my $_i26 = 0; $_i26 < $_size22; ++$_i26)
          {
            my $elem27 = undef;
            {
              my $_size28 = 0;
              $elem27 = {};
              my $_ktype29 = 0;
              my $_vtype30 = 0;
              $xfer += $input->readMapBegin(\$_ktype29, \$_vtype30, \$_size28);
              for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
              {
                my $key33 = [];
                my $val34 = [];
                {
                  my $_size35 = 0;
                  $key33 = {};
                  my $_etype38 = 0;
                  $xfer += $input->readSetBegin(\$_etype38, \$_size35);
                  for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
                  {
                    my $elem40 = undef;
                    $xfer += $input->readI32(\$elem40);
                    $key33->{$elem40} = 1;
                  }
                  $xfer += $input->readSetEnd();
                }
                {
                  my $_size41 = 0;
                  $val34 = {};
                  my $_ktype42 = 0;
                  my $_vtype43 = 0;
                  $xfer += $input->readMapBegin(\$_ktype42, \$_vtype43, \$_size41);
                  for (my $_i45 = 0; $_i45 < $_size41; ++$_i45)
                  {
                    my $key46 = 0;
                    my $val47 = [];
                    $xfer += $input->readI32(\$key46);
                    {
                      my $_size48 = 0;
                      $val47 = {};
                      my $_etype51 = 0;
                      $xfer += $input->readSetBegin(\$_etype51, \$_size48);
                      for (my $_i52 = 0; $_i52 < $_size48; ++$_i52)
                      {
                        my $elem53 = undef;
                        {
                          my $_size54 = 0;
                          $elem53 = [];
                          my $_etype57 = 0;
                          $xfer += $input->readListBegin(\$_etype57, \$_size54);
                          for (my $_i58 = 0; $_i58 < $_size54; ++$_i58)
                          {
                            my $elem59 = undef;
                            {
                              my $_size60 = 0;
                              $elem59 = {};
                              my $_ktype61 = 0;
                              my $_vtype62 = 0;
                              $xfer += $input->readMapBegin(\$_ktype61, \$_vtype62, \$_size60);
                              for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
                              {
                                my $key65 = ThriftTest::Insanity->new();
                                my $val66 = '';
                                $key65 = ThriftTest::Insanity->new();
                                $xfer += $key65->read($input);
                                $xfer += $input->readString(\$val66);
                                $elem59->{$key65} = $val66;
                              }
                              $xfer += $input->readMapEnd();
                            }
                            push(@{$elem53},$elem59);
                          }
                          $xfer += $input->readListEnd();
                        }
                        $val47->{$elem53} = 1;
                      }
                      $xfer += $input->readSetEnd();
                    }
                    $val34->{$key46} = $val47;
                  }
                  $xfer += $input->readMapEnd();
                }
                $elem27->{$key33} = $val34;
              }
              $xfer += $input->readMapEnd();
            }
            push(@{$self->{list_field}},$elem27);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{binary_field});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CrazyNesting');
  if (defined $self->{string_field}) {
    $xfer += $output->writeFieldBegin('string_field', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{string_field});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{set_field}) {
    $xfer += $output->writeFieldBegin('set_field', Thrift::TType::SET, 2);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::STRUCT, scalar(@{$self->{set_field}}));
      {
        foreach my $iter67 (@{$self->{set_field}})
        {
          $xfer += ${iter67}->write($output);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{list_field}) {
    $xfer += $output->writeFieldBegin('list_field', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::MAP, scalar(@{$self->{list_field}}));
      {
        foreach my $iter68 (@{$self->{list_field}}) 
        {
          {
            $xfer += $output->writeMapBegin(Thrift::TType::SET, Thrift::TType::MAP, scalar(keys %{${iter68}}));
            {
              while( my ($kiter69,$viter70) = each %{${iter68}}) 
              {
                {
                  $xfer += $output->writeSetBegin(Thrift::TType::I32, scalar(@{${kiter69}}));
                  {
                    foreach my $iter71 (@{${kiter69}})
                    {
                      $xfer += $output->writeI32($iter71);
                    }
                  }
                  $xfer += $output->writeSetEnd();
                }
                {
                  $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::SET, scalar(keys %{${viter70}}));
                  {
                    while( my ($kiter72,$viter73) = each %{${viter70}}) 
                    {
                      $xfer += $output->writeI32($kiter72);
                      {
                        $xfer += $output->writeSetBegin(Thrift::TType::LIST, scalar(@{${viter73}}));
                        {
                          foreach my $iter74 (@{${viter73}})
                          {
                            {
                              $xfer += $output->writeListBegin(Thrift::TType::MAP, scalar(@{${iter74}}));
                              {
                                foreach my $iter75 (@{${iter74}}) 
                                {
                                  {
                                    $xfer += $output->writeMapBegin(Thrift::TType::STRUCT, Thrift::TType::STRING, scalar(keys %{${iter75}}));
                                    {
                                      while( my ($kiter76,$viter77) = each %{${iter75}}) 
                                      {
                                        $xfer += ${kiter76}->write($output);
                                        $xfer += $output->writeString($viter77);
                                      }
                                    }
                                    $xfer += $output->writeMapEnd();
                                  }
                                }
                              }
                              $xfer += $output->writeListEnd();
                            }
                          }
                        }
                        $xfer += $output->writeSetEnd();
                      }
                    }
                  }
                  $xfer += $output->writeMapEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{binary_field}) {
    $xfer += $output->writeFieldBegin('binary_field', Thrift::TType::STRING, 4);
    $xfer += $output->writeString($self->{binary_field});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::SomeUnion;
use base qw(Class::Accessor);
ThriftTest::SomeUnion->mk_accessors( qw( map_thing string_thing i32_thing xtruct_thing insanity_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{map_thing} = undef;
  $self->{string_thing} = undef;
  $self->{i32_thing} = undef;
  $self->{xtruct_thing} = undef;
  $self->{insanity_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{map_thing}) {
      $self->{map_thing} = $vals->{map_thing};
    }
    if (defined $vals->{string_thing}) {
      $self->{string_thing} = $vals->{string_thing};
    }
    if (defined $vals->{i32_thing}) {
      $self->{i32_thing} = $vals->{i32_thing};
    }
    if (defined $vals->{xtruct_thing}) {
      $self->{xtruct_thing} = $vals->{xtruct_thing};
    }
    if (defined $vals->{insanity_thing}) {
      $self->{insanity_thing} = $vals->{insanity_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SomeUnion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size78 = 0;
          $self->{map_thing} = {};
          my $_ktype79 = 0;
          my $_vtype80 = 0;
          $xfer += $input->readMapBegin(\$_ktype79, \$_vtype80, \$_size78);
          for (my $_i82 = 0; $_i82 < $_size78; ++$_i82)
          {
            my $key83 = 0;
            my $val84 = 0;
            $xfer += $input->readI32(\$key83);
            $xfer += $input->readI64(\$val84);
            $self->{map_thing}->{$key83} = $val84;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{string_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{i32_thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{xtruct_thing} = ThriftTest::Xtruct3->new();
        $xfer += $self->{xtruct_thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{insanity_thing} = ThriftTest::Insanity->new();
        $xfer += $self->{insanity_thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SomeUnion');
  if (defined $self->{map_thing}) {
    $xfer += $output->writeFieldBegin('map_thing', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I64, scalar(keys %{$self->{map_thing}}));
      {
        while( my ($kiter85,$viter86) = each %{$self->{map_thing}}) 
        {
          $xfer += $output->writeI32($kiter85);
          $xfer += $output->writeI64($viter86);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{string_thing}) {
    $xfer += $output->writeFieldBegin('string_thing', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{string_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32_thing}) {
    $xfer += $output->writeFieldBegin('i32_thing', Thrift::TType::I32, 3);
    $xfer += $output->writeI32($self->{i32_thing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{xtruct_thing}) {
    $xfer += $output->writeFieldBegin('xtruct_thing', Thrift::TType::STRUCT, 4);
    $xfer += $self->{xtruct_thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{insanity_thing}) {
    $xfer += $output->writeFieldBegin('insanity_thing', Thrift::TType::STRUCT, 5);
    $xfer += $self->{insanity_thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xception;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
ThriftTest::Xception->mk_accessors( qw( errorCode message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{errorCode} = undef;
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{errorCode}) {
      $self->{errorCode} = $vals->{errorCode};
    }
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xception';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{errorCode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xception');
  if (defined $self->{errorCode}) {
    $xfer += $output->writeFieldBegin('errorCode', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{errorCode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::Xception2;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
ThriftTest::Xception2->mk_accessors( qw( errorCode struct_thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{errorCode} = undef;
  $self->{struct_thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{errorCode}) {
      $self->{errorCode} = $vals->{errorCode};
    }
    if (defined $vals->{struct_thing}) {
      $self->{struct_thing} = $vals->{struct_thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Xception2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{errorCode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{struct_thing} = ThriftTest::Xtruct->new();
        $xfer += $self->{struct_thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Xception2');
  if (defined $self->{errorCode}) {
    $xfer += $output->writeFieldBegin('errorCode', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{errorCode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{struct_thing}) {
    $xfer += $output->writeFieldBegin('struct_thing', Thrift::TType::STRUCT, 2);
    $xfer += $self->{struct_thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::EmptyStruct;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'EmptyStruct';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EmptyStruct');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::OneField;
use base qw(Class::Accessor);
ThriftTest::OneField->mk_accessors( qw( field ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{field} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{field}) {
      $self->{field} = $vals->{field};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'OneField';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{field} = ThriftTest::EmptyStruct->new();
        $xfer += $self->{field}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('OneField');
  if (defined $self->{field}) {
    $xfer += $output->writeFieldBegin('field', Thrift::TType::STRUCT, 1);
    $xfer += $self->{field}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::VersioningTestV1;
use base qw(Class::Accessor);
ThriftTest::VersioningTestV1->mk_accessors( qw( begin_in_both old_string end_in_both ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{begin_in_both} = undef;
  $self->{old_string} = undef;
  $self->{end_in_both} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{begin_in_both}) {
      $self->{begin_in_both} = $vals->{begin_in_both};
    }
    if (defined $vals->{old_string}) {
      $self->{old_string} = $vals->{old_string};
    }
    if (defined $vals->{end_in_both}) {
      $self->{end_in_both} = $vals->{end_in_both};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'VersioningTestV1';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{begin_in_both});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{old_string});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{end_in_both});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('VersioningTestV1');
  if (defined $self->{begin_in_both}) {
    $xfer += $output->writeFieldBegin('begin_in_both', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{begin_in_both});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{old_string}) {
    $xfer += $output->writeFieldBegin('old_string', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{old_string});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_in_both}) {
    $xfer += $output->writeFieldBegin('end_in_both', Thrift::TType::I32, 12);
    $xfer += $output->writeI32($self->{end_in_both});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::VersioningTestV2;
use base qw(Class::Accessor);
ThriftTest::VersioningTestV2->mk_accessors( qw( begin_in_both newint newbyte newshort newlong newdouble newstruct newlist newset newmap newstring end_in_both ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{begin_in_both} = undef;
  $self->{newint} = undef;
  $self->{newbyte} = undef;
  $self->{newshort} = undef;
  $self->{newlong} = undef;
  $self->{newdouble} = undef;
  $self->{newstruct} = undef;
  $self->{newlist} = undef;
  $self->{newset} = undef;
  $self->{newmap} = undef;
  $self->{newstring} = undef;
  $self->{end_in_both} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{begin_in_both}) {
      $self->{begin_in_both} = $vals->{begin_in_both};
    }
    if (defined $vals->{newint}) {
      $self->{newint} = $vals->{newint};
    }
    if (defined $vals->{newbyte}) {
      $self->{newbyte} = $vals->{newbyte};
    }
    if (defined $vals->{newshort}) {
      $self->{newshort} = $vals->{newshort};
    }
    if (defined $vals->{newlong}) {
      $self->{newlong} = $vals->{newlong};
    }
    if (defined $vals->{newdouble}) {
      $self->{newdouble} = $vals->{newdouble};
    }
    if (defined $vals->{newstruct}) {
      $self->{newstruct} = $vals->{newstruct};
    }
    if (defined $vals->{newlist}) {
      $self->{newlist} = $vals->{newlist};
    }
    if (defined $vals->{newset}) {
      $self->{newset} = $vals->{newset};
    }
    if (defined $vals->{newmap}) {
      $self->{newmap} = $vals->{newmap};
    }
    if (defined $vals->{newstring}) {
      $self->{newstring} = $vals->{newstring};
    }
    if (defined $vals->{end_in_both}) {
      $self->{end_in_both} = $vals->{end_in_both};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'VersioningTestV2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{begin_in_both});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{newint});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{newbyte});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I16) {
        $xfer += $input->readI16(\$self->{newshort});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{newlong});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{newdouble});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{newstruct} = ThriftTest::Bonk->new();
        $xfer += $self->{newstruct}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size87 = 0;
          $self->{newlist} = [];
          my $_etype90 = 0;
          $xfer += $input->readListBegin(\$_etype90, \$_size87);
          for (my $_i91 = 0; $_i91 < $_size87; ++$_i91)
          {
            my $elem92 = undef;
            $xfer += $input->readI32(\$elem92);
            push(@{$self->{newlist}},$elem92);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size93 = 0;
          $self->{newset} = {};
          my $_etype96 = 0;
          $xfer += $input->readSetBegin(\$_etype96, \$_size93);
          for (my $_i97 = 0; $_i97 < $_size93; ++$_i97)
          {
            my $elem98 = undef;
            $xfer += $input->readI32(\$elem98);
            $self->{newset}->{$elem98} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size99 = 0;
          $self->{newmap} = {};
          my $_ktype100 = 0;
          my $_vtype101 = 0;
          $xfer += $input->readMapBegin(\$_ktype100, \$_vtype101, \$_size99);
          for (my $_i103 = 0; $_i103 < $_size99; ++$_i103)
          {
            my $key104 = 0;
            my $val105 = 0;
            $xfer += $input->readI32(\$key104);
            $xfer += $input->readI32(\$val105);
            $self->{newmap}->{$key104} = $val105;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{newstring});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{end_in_both});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('VersioningTestV2');
  if (defined $self->{begin_in_both}) {
    $xfer += $output->writeFieldBegin('begin_in_both', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{begin_in_both});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newint}) {
    $xfer += $output->writeFieldBegin('newint', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{newint});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newbyte}) {
    $xfer += $output->writeFieldBegin('newbyte', Thrift::TType::BYTE, 3);
    $xfer += $output->writeByte($self->{newbyte});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newshort}) {
    $xfer += $output->writeFieldBegin('newshort', Thrift::TType::I16, 4);
    $xfer += $output->writeI16($self->{newshort});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newlong}) {
    $xfer += $output->writeFieldBegin('newlong', Thrift::TType::I64, 5);
    $xfer += $output->writeI64($self->{newlong});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newdouble}) {
    $xfer += $output->writeFieldBegin('newdouble', Thrift::TType::DOUBLE, 6);
    $xfer += $output->writeDouble($self->{newdouble});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newstruct}) {
    $xfer += $output->writeFieldBegin('newstruct', Thrift::TType::STRUCT, 7);
    $xfer += $self->{newstruct}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newlist}) {
    $xfer += $output->writeFieldBegin('newlist', Thrift::TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{newlist}}));
      {
        foreach my $iter106 (@{$self->{newlist}}) 
        {
          $xfer += $output->writeI32($iter106);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newset}) {
    $xfer += $output->writeFieldBegin('newset', Thrift::TType::SET, 9);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::I32, scalar(@{$self->{newset}}));
      {
        foreach my $iter107 (@{$self->{newset}})
        {
          $xfer += $output->writeI32($iter107);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newmap}) {
    $xfer += $output->writeFieldBegin('newmap', Thrift::TType::MAP, 10);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I32, scalar(keys %{$self->{newmap}}));
      {
        while( my ($kiter108,$viter109) = each %{$self->{newmap}}) 
        {
          $xfer += $output->writeI32($kiter108);
          $xfer += $output->writeI32($viter109);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{newstring}) {
    $xfer += $output->writeFieldBegin('newstring', Thrift::TType::STRING, 11);
    $xfer += $output->writeString($self->{newstring});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_in_both}) {
    $xfer += $output->writeFieldBegin('end_in_both', Thrift::TType::I32, 12);
    $xfer += $output->writeI32($self->{end_in_both});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ListTypeVersioningV1;
use base qw(Class::Accessor);
ThriftTest::ListTypeVersioningV1->mk_accessors( qw( myints hello ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{myints} = undef;
  $self->{hello} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{myints}) {
      $self->{myints} = $vals->{myints};
    }
    if (defined $vals->{hello}) {
      $self->{hello} = $vals->{hello};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ListTypeVersioningV1';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size110 = 0;
          $self->{myints} = [];
          my $_etype113 = 0;
          $xfer += $input->readListBegin(\$_etype113, \$_size110);
          for (my $_i114 = 0; $_i114 < $_size110; ++$_i114)
          {
            my $elem115 = undef;
            $xfer += $input->readI32(\$elem115);
            push(@{$self->{myints}},$elem115);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{hello});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ListTypeVersioningV1');
  if (defined $self->{myints}) {
    $xfer += $output->writeFieldBegin('myints', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{myints}}));
      {
        foreach my $iter116 (@{$self->{myints}}) 
        {
          $xfer += $output->writeI32($iter116);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hello}) {
    $xfer += $output->writeFieldBegin('hello', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{hello});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ListTypeVersioningV2;
use base qw(Class::Accessor);
ThriftTest::ListTypeVersioningV2->mk_accessors( qw( strings hello ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{strings} = undef;
  $self->{hello} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{strings}) {
      $self->{strings} = $vals->{strings};
    }
    if (defined $vals->{hello}) {
      $self->{hello} = $vals->{hello};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ListTypeVersioningV2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size117 = 0;
          $self->{strings} = [];
          my $_etype120 = 0;
          $xfer += $input->readListBegin(\$_etype120, \$_size117);
          for (my $_i121 = 0; $_i121 < $_size117; ++$_i121)
          {
            my $elem122 = undef;
            $xfer += $input->readString(\$elem122);
            push(@{$self->{strings}},$elem122);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{hello});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ListTypeVersioningV2');
  if (defined $self->{strings}) {
    $xfer += $output->writeFieldBegin('strings', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{strings}}));
      {
        foreach my $iter123 (@{$self->{strings}}) 
        {
          $xfer += $output->writeString($iter123);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hello}) {
    $xfer += $output->writeFieldBegin('hello', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{hello});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::GuessProtocolStruct;
use base qw(Class::Accessor);
ThriftTest::GuessProtocolStruct->mk_accessors( qw( map_field ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{map_field} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{map_field}) {
      $self->{map_field} = $vals->{map_field};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'GuessProtocolStruct';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^7$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size124 = 0;
          $self->{map_field} = {};
          my $_ktype125 = 0;
          my $_vtype126 = 0;
          $xfer += $input->readMapBegin(\$_ktype125, \$_vtype126, \$_size124);
          for (my $_i128 = 0; $_i128 < $_size124; ++$_i128)
          {
            my $key129 = '';
            my $val130 = '';
            $xfer += $input->readString(\$key129);
            $xfer += $input->readString(\$val130);
            $self->{map_field}->{$key129} = $val130;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('GuessProtocolStruct');
  if (defined $self->{map_field}) {
    $xfer += $output->writeFieldBegin('map_field', Thrift::TType::MAP, 7);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{map_field}}));
      {
        while( my ($kiter131,$viter132) = each %{$self->{map_field}}) 
        {
          $xfer += $output->writeString($kiter131);
          $xfer += $output->writeString($viter132);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::LargeDeltas;
use base qw(Class::Accessor);
ThriftTest::LargeDeltas->mk_accessors( qw( b1 b10 b100 check_true b1000 check_false vertwo2000 a_set2500 vertwo3000 big_numbers ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{b1} = undef;
  $self->{b10} = undef;
  $self->{b100} = undef;
  $self->{check_true} = undef;
  $self->{b1000} = undef;
  $self->{check_false} = undef;
  $self->{vertwo2000} = undef;
  $self->{a_set2500} = undef;
  $self->{vertwo3000} = undef;
  $self->{big_numbers} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{b1}) {
      $self->{b1} = $vals->{b1};
    }
    if (defined $vals->{b10}) {
      $self->{b10} = $vals->{b10};
    }
    if (defined $vals->{b100}) {
      $self->{b100} = $vals->{b100};
    }
    if (defined $vals->{check_true}) {
      $self->{check_true} = $vals->{check_true};
    }
    if (defined $vals->{b1000}) {
      $self->{b1000} = $vals->{b1000};
    }
    if (defined $vals->{check_false}) {
      $self->{check_false} = $vals->{check_false};
    }
    if (defined $vals->{vertwo2000}) {
      $self->{vertwo2000} = $vals->{vertwo2000};
    }
    if (defined $vals->{a_set2500}) {
      $self->{a_set2500} = $vals->{a_set2500};
    }
    if (defined $vals->{vertwo3000}) {
      $self->{vertwo3000} = $vals->{vertwo3000};
    }
    if (defined $vals->{big_numbers}) {
      $self->{big_numbers} = $vals->{big_numbers};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'LargeDeltas';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{b1} = ThriftTest::Bools->new();
        $xfer += $self->{b1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{b10} = ThriftTest::Bools->new();
        $xfer += $self->{b10}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^100$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{b100} = ThriftTest::Bools->new();
        $xfer += $self->{b100}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^500$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{check_true});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1000$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{b1000} = ThriftTest::Bools->new();
        $xfer += $self->{b1000}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1500$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{check_false});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2000$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{vertwo2000} = ThriftTest::VersioningTestV2->new();
        $xfer += $self->{vertwo2000}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2500$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size133 = 0;
          $self->{a_set2500} = {};
          my $_etype136 = 0;
          $xfer += $input->readSetBegin(\$_etype136, \$_size133);
          for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
          {
            my $elem138 = undef;
            $xfer += $input->readString(\$elem138);
            $self->{a_set2500}->{$elem138} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3000$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{vertwo3000} = ThriftTest::VersioningTestV2->new();
        $xfer += $self->{vertwo3000}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4000$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size139 = 0;
          $self->{big_numbers} = [];
          my $_etype142 = 0;
          $xfer += $input->readListBegin(\$_etype142, \$_size139);
          for (my $_i143 = 0; $_i143 < $_size139; ++$_i143)
          {
            my $elem144 = undef;
            $xfer += $input->readI32(\$elem144);
            push(@{$self->{big_numbers}},$elem144);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('LargeDeltas');
  if (defined $self->{b1}) {
    $xfer += $output->writeFieldBegin('b1', Thrift::TType::STRUCT, 1);
    $xfer += $self->{b1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{b10}) {
    $xfer += $output->writeFieldBegin('b10', Thrift::TType::STRUCT, 10);
    $xfer += $self->{b10}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{b100}) {
    $xfer += $output->writeFieldBegin('b100', Thrift::TType::STRUCT, 100);
    $xfer += $self->{b100}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{check_true}) {
    $xfer += $output->writeFieldBegin('check_true', Thrift::TType::BOOL, 500);
    $xfer += $output->writeBool($self->{check_true});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{b1000}) {
    $xfer += $output->writeFieldBegin('b1000', Thrift::TType::STRUCT, 1000);
    $xfer += $self->{b1000}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{check_false}) {
    $xfer += $output->writeFieldBegin('check_false', Thrift::TType::BOOL, 1500);
    $xfer += $output->writeBool($self->{check_false});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{vertwo2000}) {
    $xfer += $output->writeFieldBegin('vertwo2000', Thrift::TType::STRUCT, 2000);
    $xfer += $self->{vertwo2000}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{a_set2500}) {
    $xfer += $output->writeFieldBegin('a_set2500', Thrift::TType::SET, 2500);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{a_set2500}}));
      {
        foreach my $iter145 (@{$self->{a_set2500}})
        {
          $xfer += $output->writeString($iter145);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{vertwo3000}) {
    $xfer += $output->writeFieldBegin('vertwo3000', Thrift::TType::STRUCT, 3000);
    $xfer += $self->{vertwo3000}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{big_numbers}) {
    $xfer += $output->writeFieldBegin('big_numbers', Thrift::TType::LIST, 4000);
    {
      $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{big_numbers}}));
      {
        foreach my $iter146 (@{$self->{big_numbers}}) 
        {
          $xfer += $output->writeI32($iter146);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::NestedListsI32x2;
use base qw(Class::Accessor);
ThriftTest::NestedListsI32x2->mk_accessors( qw( integerlist ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{integerlist} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{integerlist}) {
      $self->{integerlist} = $vals->{integerlist};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NestedListsI32x2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size147 = 0;
          $self->{integerlist} = [];
          my $_etype150 = 0;
          $xfer += $input->readListBegin(\$_etype150, \$_size147);
          for (my $_i151 = 0; $_i151 < $_size147; ++$_i151)
          {
            my $elem152 = undef;
            {
              my $_size153 = 0;
              $elem152 = [];
              my $_etype156 = 0;
              $xfer += $input->readListBegin(\$_etype156, \$_size153);
              for (my $_i157 = 0; $_i157 < $_size153; ++$_i157)
              {
                my $elem158 = undef;
                $xfer += $input->readI32(\$elem158);
                push(@{$elem152},$elem158);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{integerlist}},$elem152);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NestedListsI32x2');
  if (defined $self->{integerlist}) {
    $xfer += $output->writeFieldBegin('integerlist', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{integerlist}}));
      {
        foreach my $iter159 (@{$self->{integerlist}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{${iter159}}));
            {
              foreach my $iter160 (@{${iter159}}) 
              {
                $xfer += $output->writeI32($iter160);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::NestedListsI32x3;
use base qw(Class::Accessor);
ThriftTest::NestedListsI32x3->mk_accessors( qw( integerlist ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{integerlist} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{integerlist}) {
      $self->{integerlist} = $vals->{integerlist};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NestedListsI32x3';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size161 = 0;
          $self->{integerlist} = [];
          my $_etype164 = 0;
          $xfer += $input->readListBegin(\$_etype164, \$_size161);
          for (my $_i165 = 0; $_i165 < $_size161; ++$_i165)
          {
            my $elem166 = undef;
            {
              my $_size167 = 0;
              $elem166 = [];
              my $_etype170 = 0;
              $xfer += $input->readListBegin(\$_etype170, \$_size167);
              for (my $_i171 = 0; $_i171 < $_size167; ++$_i171)
              {
                my $elem172 = undef;
                {
                  my $_size173 = 0;
                  $elem172 = [];
                  my $_etype176 = 0;
                  $xfer += $input->readListBegin(\$_etype176, \$_size173);
                  for (my $_i177 = 0; $_i177 < $_size173; ++$_i177)
                  {
                    my $elem178 = undef;
                    $xfer += $input->readI32(\$elem178);
                    push(@{$elem172},$elem178);
                  }
                  $xfer += $input->readListEnd();
                }
                push(@{$elem166},$elem172);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{integerlist}},$elem166);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NestedListsI32x3');
  if (defined $self->{integerlist}) {
    $xfer += $output->writeFieldBegin('integerlist', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{integerlist}}));
      {
        foreach my $iter179 (@{$self->{integerlist}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{${iter179}}));
            {
              foreach my $iter180 (@{${iter179}}) 
              {
                {
                  $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{${iter180}}));
                  {
                    foreach my $iter181 (@{${iter180}}) 
                    {
                      $xfer += $output->writeI32($iter181);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::NestedMixedx2;
use base qw(Class::Accessor);
ThriftTest::NestedMixedx2->mk_accessors( qw( int_set_list map_int_strset map_int_strset_list ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{int_set_list} = undef;
  $self->{map_int_strset} = undef;
  $self->{map_int_strset_list} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{int_set_list}) {
      $self->{int_set_list} = $vals->{int_set_list};
    }
    if (defined $vals->{map_int_strset}) {
      $self->{map_int_strset} = $vals->{map_int_strset};
    }
    if (defined $vals->{map_int_strset_list}) {
      $self->{map_int_strset_list} = $vals->{map_int_strset_list};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NestedMixedx2';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size182 = 0;
          $self->{int_set_list} = [];
          my $_etype185 = 0;
          $xfer += $input->readListBegin(\$_etype185, \$_size182);
          for (my $_i186 = 0; $_i186 < $_size182; ++$_i186)
          {
            my $elem187 = undef;
            {
              my $_size188 = 0;
              $elem187 = {};
              my $_etype191 = 0;
              $xfer += $input->readSetBegin(\$_etype191, \$_size188);
              for (my $_i192 = 0; $_i192 < $_size188; ++$_i192)
              {
                my $elem193 = undef;
                $xfer += $input->readI32(\$elem193);
                $elem187->{$elem193} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            push(@{$self->{int_set_list}},$elem187);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size194 = 0;
          $self->{map_int_strset} = {};
          my $_ktype195 = 0;
          my $_vtype196 = 0;
          $xfer += $input->readMapBegin(\$_ktype195, \$_vtype196, \$_size194);
          for (my $_i198 = 0; $_i198 < $_size194; ++$_i198)
          {
            my $key199 = 0;
            my $val200 = [];
            $xfer += $input->readI32(\$key199);
            {
              my $_size201 = 0;
              $val200 = {};
              my $_etype204 = 0;
              $xfer += $input->readSetBegin(\$_etype204, \$_size201);
              for (my $_i205 = 0; $_i205 < $_size201; ++$_i205)
              {
                my $elem206 = undef;
                $xfer += $input->readString(\$elem206);
                $val200->{$elem206} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{map_int_strset}->{$key199} = $val200;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size207 = 0;
          $self->{map_int_strset_list} = [];
          my $_etype210 = 0;
          $xfer += $input->readListBegin(\$_etype210, \$_size207);
          for (my $_i211 = 0; $_i211 < $_size207; ++$_i211)
          {
            my $elem212 = undef;
            {
              my $_size213 = 0;
              $elem212 = {};
              my $_ktype214 = 0;
              my $_vtype215 = 0;
              $xfer += $input->readMapBegin(\$_ktype214, \$_vtype215, \$_size213);
              for (my $_i217 = 0; $_i217 < $_size213; ++$_i217)
              {
                my $key218 = 0;
                my $val219 = [];
                $xfer += $input->readI32(\$key218);
                {
                  my $_size220 = 0;
                  $val219 = {};
                  my $_etype223 = 0;
                  $xfer += $input->readSetBegin(\$_etype223, \$_size220);
                  for (my $_i224 = 0; $_i224 < $_size220; ++$_i224)
                  {
                    my $elem225 = undef;
                    $xfer += $input->readString(\$elem225);
                    $val219->{$elem225} = 1;
                  }
                  $xfer += $input->readSetEnd();
                }
                $elem212->{$key218} = $val219;
              }
              $xfer += $input->readMapEnd();
            }
            push(@{$self->{map_int_strset_list}},$elem212);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NestedMixedx2');
  if (defined $self->{int_set_list}) {
    $xfer += $output->writeFieldBegin('int_set_list', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::SET, scalar(@{$self->{int_set_list}}));
      {
        foreach my $iter226 (@{$self->{int_set_list}}) 
        {
          {
            $xfer += $output->writeSetBegin(Thrift::TType::I32, scalar(@{${iter226}}));
            {
              foreach my $iter227 (@{${iter226}})
              {
                $xfer += $output->writeI32($iter227);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{map_int_strset}) {
    $xfer += $output->writeFieldBegin('map_int_strset', Thrift::TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::SET, scalar(keys %{$self->{map_int_strset}}));
      {
        while( my ($kiter228,$viter229) = each %{$self->{map_int_strset}}) 
        {
          $xfer += $output->writeI32($kiter228);
          {
            $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{${viter229}}));
            {
              foreach my $iter230 (@{${viter229}})
              {
                $xfer += $output->writeString($iter230);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{map_int_strset_list}) {
    $xfer += $output->writeFieldBegin('map_int_strset_list', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::MAP, scalar(@{$self->{map_int_strset_list}}));
      {
        foreach my $iter231 (@{$self->{map_int_strset_list}}) 
        {
          {
            $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::SET, scalar(keys %{${iter231}}));
            {
              while( my ($kiter232,$viter233) = each %{${iter231}}) 
              {
                $xfer += $output->writeI32($kiter232);
                {
                  $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{${viter233}}));
                  {
                    foreach my $iter234 (@{${viter233}})
                    {
                      $xfer += $output->writeString($iter234);
                    }
                  }
                  $xfer += $output->writeSetEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ListBonks;
use base qw(Class::Accessor);
ThriftTest::ListBonks->mk_accessors( qw( bonk ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bonk} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bonk}) {
      $self->{bonk} = $vals->{bonk};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ListBonks';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size235 = 0;
          $self->{bonk} = [];
          my $_etype238 = 0;
          $xfer += $input->readListBegin(\$_etype238, \$_size235);
          for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
          {
            my $elem240 = undef;
            $elem240 = ThriftTest::Bonk->new();
            $xfer += $elem240->read($input);
            push(@{$self->{bonk}},$elem240);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ListBonks');
  if (defined $self->{bonk}) {
    $xfer += $output->writeFieldBegin('bonk', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{bonk}}));
      {
        foreach my $iter241 (@{$self->{bonk}}) 
        {
          $xfer += ${iter241}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::NestedListsBonk;
use base qw(Class::Accessor);
ThriftTest::NestedListsBonk->mk_accessors( qw( bonk ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bonk} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bonk}) {
      $self->{bonk} = $vals->{bonk};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NestedListsBonk';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size242 = 0;
          $self->{bonk} = [];
          my $_etype245 = 0;
          $xfer += $input->readListBegin(\$_etype245, \$_size242);
          for (my $_i246 = 0; $_i246 < $_size242; ++$_i246)
          {
            my $elem247 = undef;
            {
              my $_size248 = 0;
              $elem247 = [];
              my $_etype251 = 0;
              $xfer += $input->readListBegin(\$_etype251, \$_size248);
              for (my $_i252 = 0; $_i252 < $_size248; ++$_i252)
              {
                my $elem253 = undef;
                {
                  my $_size254 = 0;
                  $elem253 = [];
                  my $_etype257 = 0;
                  $xfer += $input->readListBegin(\$_etype257, \$_size254);
                  for (my $_i258 = 0; $_i258 < $_size254; ++$_i258)
                  {
                    my $elem259 = undef;
                    $elem259 = ThriftTest::Bonk->new();
                    $xfer += $elem259->read($input);
                    push(@{$elem253},$elem259);
                  }
                  $xfer += $input->readListEnd();
                }
                push(@{$elem247},$elem253);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{bonk}},$elem247);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NestedListsBonk');
  if (defined $self->{bonk}) {
    $xfer += $output->writeFieldBegin('bonk', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{$self->{bonk}}));
      {
        foreach my $iter260 (@{$self->{bonk}}) 
        {
          {
            $xfer += $output->writeListBegin(Thrift::TType::LIST, scalar(@{${iter260}}));
            {
              foreach my $iter261 (@{${iter260}}) 
              {
                {
                  $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{${iter261}}));
                  {
                    foreach my $iter262 (@{${iter261}}) 
                    {
                      $xfer += ${iter262}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::BoolTest;
use base qw(Class::Accessor);
ThriftTest::BoolTest->mk_accessors( qw( b s ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{b} = 1;
  $self->{s} = "true";
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{b}) {
      $self->{b} = $vals->{b};
    }
    if (defined $vals->{s}) {
      $self->{s} = $vals->{s};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BoolTest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{b});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{s});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BoolTest');
  if (defined $self->{b}) {
    $xfer += $output->writeFieldBegin('b', Thrift::TType::BOOL, 1);
    $xfer += $output->writeBool($self->{b});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{s}) {
    $xfer += $output->writeFieldBegin('s', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{s});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::StructA;
use base qw(Class::Accessor);
ThriftTest::StructA->mk_accessors( qw( s ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{s} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{s}) {
      $self->{s} = $vals->{s};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StructA';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{s});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StructA');
  if (defined $self->{s}) {
    $xfer += $output->writeFieldBegin('s', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{s});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::StructB;
use base qw(Class::Accessor);
ThriftTest::StructB->mk_accessors( qw( aa ab ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{aa} = undef;
  $self->{ab} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{aa}) {
      $self->{aa} = $vals->{aa};
    }
    if (defined $vals->{ab}) {
      $self->{ab} = $vals->{ab};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StructB';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{aa} = ThriftTest::StructA->new();
        $xfer += $self->{aa}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ab} = ThriftTest::StructA->new();
        $xfer += $self->{ab}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StructB');
  if (defined $self->{aa}) {
    $xfer += $output->writeFieldBegin('aa', Thrift::TType::STRUCT, 1);
    $xfer += $self->{aa}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ab}) {
    $xfer += $output->writeFieldBegin('ab', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ab}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::OptionalSetDefaultTest;
use base qw(Class::Accessor);
ThriftTest::OptionalSetDefaultTest->mk_accessors( qw( with_default ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{with_default} = [
    "test" => 1,
  ];
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{with_default}) {
      $self->{with_default} = $vals->{with_default};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'OptionalSetDefaultTest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size263 = 0;
          $self->{with_default} = {};
          my $_etype266 = 0;
          $xfer += $input->readSetBegin(\$_etype266, \$_size263);
          for (my $_i267 = 0; $_i267 < $_size263; ++$_i267)
          {
            my $elem268 = undef;
            $xfer += $input->readString(\$elem268);
            $self->{with_default}->{$elem268} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('OptionalSetDefaultTest');
  if (defined $self->{with_default}) {
    $xfer += $output->writeFieldBegin('with_default', Thrift::TType::SET, 1);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{with_default}}));
      {
        foreach my $iter269 (@{$self->{with_default}})
        {
          $xfer += $output->writeString($iter269);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::OptionalBinary;
use base qw(Class::Accessor);
ThriftTest::OptionalBinary->mk_accessors( qw( bin_set bin_map ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{bin_set} = [
  ];
  $self->{bin_map} = {
  };
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{bin_set}) {
      $self->{bin_set} = $vals->{bin_set};
    }
    if (defined $vals->{bin_map}) {
      $self->{bin_map} = $vals->{bin_map};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'OptionalBinary';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size270 = 0;
          $self->{bin_set} = {};
          my $_etype273 = 0;
          $xfer += $input->readSetBegin(\$_etype273, \$_size270);
          for (my $_i274 = 0; $_i274 < $_size270; ++$_i274)
          {
            my $elem275 = undef;
            $xfer += $input->readString(\$elem275);
            $self->{bin_set}->{$elem275} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size276 = 0;
          $self->{bin_map} = {};
          my $_ktype277 = 0;
          my $_vtype278 = 0;
          $xfer += $input->readMapBegin(\$_ktype277, \$_vtype278, \$_size276);
          for (my $_i280 = 0; $_i280 < $_size276; ++$_i280)
          {
            my $key281 = '';
            my $val282 = 0;
            $xfer += $input->readString(\$key281);
            $xfer += $input->readI32(\$val282);
            $self->{bin_map}->{$key281} = $val282;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('OptionalBinary');
  if (defined $self->{bin_set}) {
    $xfer += $output->writeFieldBegin('bin_set', Thrift::TType::SET, 1);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::STRING, scalar(@{$self->{bin_set}}));
      {
        foreach my $iter283 (@{$self->{bin_set}})
        {
          $xfer += $output->writeString($iter283);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bin_map}) {
    $xfer += $output->writeFieldBegin('bin_map', Thrift::TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::I32, scalar(keys %{$self->{bin_map}}));
      {
        while( my ($kiter284,$viter285) = each %{$self->{bin_map}}) 
        {
          $xfer += $output->writeString($kiter284);
          $xfer += $output->writeI32($viter285);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
